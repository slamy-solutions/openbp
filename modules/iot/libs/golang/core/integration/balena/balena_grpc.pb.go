// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.12.4
// source: balena.proto

package balena

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// BalenaServersServiceClient is the client API for BalenaServersService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BalenaServersServiceClient interface {
	// Create (register in the system) new balena server
	Create(ctx context.Context, in *CreateServerRequest, opts ...grpc.CallOption) (*CreateServerResponse, error)
	// Get balena server information
	Get(ctx context.Context, in *GetServerRequest, opts ...grpc.CallOption) (*GetServerResponse, error)
	// Get all the registered balena servers
	List(ctx context.Context, in *ListServersRequest, opts ...grpc.CallOption) (BalenaServersService_ListClient, error)
	// Get total count of all the registered balena servers
	Count(ctx context.Context, in *CountServersRequest, opts ...grpc.CallOption) (*CountServersResponse, error)
	// Get all the registered balena servers in specified namespace
	ListInNamespace(ctx context.Context, in *ListServersInNamespaceRequest, opts ...grpc.CallOption) (BalenaServersService_ListInNamespaceClient, error)
	// Get total count of all the registered balena servers in specified namespace
	CountInNamespace(ctx context.Context, in *CountServersInNamespaceRequest, opts ...grpc.CallOption) (*CountServersInNamespaceResponse, error)
	// Set status of the balena servers. Servers that are enabled will be periodically automatically synchronized.
	SetEnabled(ctx context.Context, in *SetServerEnabledRequest, opts ...grpc.CallOption) (*SetServerEnabledResponse, error)
	// Update balena server information
	Update(ctx context.Context, in *UpdateServerRequest, opts ...grpc.CallOption) (*UpdateServerResponse, error)
	// Delete balena server
	Delete(ctx context.Context, in *DeleteServerRequest, opts ...grpc.CallOption) (*DeleteServerResponse, error)
}

type balenaServersServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBalenaServersServiceClient(cc grpc.ClientConnInterface) BalenaServersServiceClient {
	return &balenaServersServiceClient{cc}
}

func (c *balenaServersServiceClient) Create(ctx context.Context, in *CreateServerRequest, opts ...grpc.CallOption) (*CreateServerResponse, error) {
	out := new(CreateServerResponse)
	err := c.cc.Invoke(ctx, "/iot_core_integration_balena.BalenaServersService/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *balenaServersServiceClient) Get(ctx context.Context, in *GetServerRequest, opts ...grpc.CallOption) (*GetServerResponse, error) {
	out := new(GetServerResponse)
	err := c.cc.Invoke(ctx, "/iot_core_integration_balena.BalenaServersService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *balenaServersServiceClient) List(ctx context.Context, in *ListServersRequest, opts ...grpc.CallOption) (BalenaServersService_ListClient, error) {
	stream, err := c.cc.NewStream(ctx, &BalenaServersService_ServiceDesc.Streams[0], "/iot_core_integration_balena.BalenaServersService/List", opts...)
	if err != nil {
		return nil, err
	}
	x := &balenaServersServiceListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BalenaServersService_ListClient interface {
	Recv() (*ListServersResponse, error)
	grpc.ClientStream
}

type balenaServersServiceListClient struct {
	grpc.ClientStream
}

func (x *balenaServersServiceListClient) Recv() (*ListServersResponse, error) {
	m := new(ListServersResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *balenaServersServiceClient) Count(ctx context.Context, in *CountServersRequest, opts ...grpc.CallOption) (*CountServersResponse, error) {
	out := new(CountServersResponse)
	err := c.cc.Invoke(ctx, "/iot_core_integration_balena.BalenaServersService/Count", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *balenaServersServiceClient) ListInNamespace(ctx context.Context, in *ListServersInNamespaceRequest, opts ...grpc.CallOption) (BalenaServersService_ListInNamespaceClient, error) {
	stream, err := c.cc.NewStream(ctx, &BalenaServersService_ServiceDesc.Streams[1], "/iot_core_integration_balena.BalenaServersService/ListInNamespace", opts...)
	if err != nil {
		return nil, err
	}
	x := &balenaServersServiceListInNamespaceClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BalenaServersService_ListInNamespaceClient interface {
	Recv() (*ListServersInNamespaceResponse, error)
	grpc.ClientStream
}

type balenaServersServiceListInNamespaceClient struct {
	grpc.ClientStream
}

func (x *balenaServersServiceListInNamespaceClient) Recv() (*ListServersInNamespaceResponse, error) {
	m := new(ListServersInNamespaceResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *balenaServersServiceClient) CountInNamespace(ctx context.Context, in *CountServersInNamespaceRequest, opts ...grpc.CallOption) (*CountServersInNamespaceResponse, error) {
	out := new(CountServersInNamespaceResponse)
	err := c.cc.Invoke(ctx, "/iot_core_integration_balena.BalenaServersService/CountInNamespace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *balenaServersServiceClient) SetEnabled(ctx context.Context, in *SetServerEnabledRequest, opts ...grpc.CallOption) (*SetServerEnabledResponse, error) {
	out := new(SetServerEnabledResponse)
	err := c.cc.Invoke(ctx, "/iot_core_integration_balena.BalenaServersService/SetEnabled", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *balenaServersServiceClient) Update(ctx context.Context, in *UpdateServerRequest, opts ...grpc.CallOption) (*UpdateServerResponse, error) {
	out := new(UpdateServerResponse)
	err := c.cc.Invoke(ctx, "/iot_core_integration_balena.BalenaServersService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *balenaServersServiceClient) Delete(ctx context.Context, in *DeleteServerRequest, opts ...grpc.CallOption) (*DeleteServerResponse, error) {
	out := new(DeleteServerResponse)
	err := c.cc.Invoke(ctx, "/iot_core_integration_balena.BalenaServersService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BalenaServersServiceServer is the server API for BalenaServersService service.
// All implementations must embed UnimplementedBalenaServersServiceServer
// for forward compatibility
type BalenaServersServiceServer interface {
	// Create (register in the system) new balena server
	Create(context.Context, *CreateServerRequest) (*CreateServerResponse, error)
	// Get balena server information
	Get(context.Context, *GetServerRequest) (*GetServerResponse, error)
	// Get all the registered balena servers
	List(*ListServersRequest, BalenaServersService_ListServer) error
	// Get total count of all the registered balena servers
	Count(context.Context, *CountServersRequest) (*CountServersResponse, error)
	// Get all the registered balena servers in specified namespace
	ListInNamespace(*ListServersInNamespaceRequest, BalenaServersService_ListInNamespaceServer) error
	// Get total count of all the registered balena servers in specified namespace
	CountInNamespace(context.Context, *CountServersInNamespaceRequest) (*CountServersInNamespaceResponse, error)
	// Set status of the balena servers. Servers that are enabled will be periodically automatically synchronized.
	SetEnabled(context.Context, *SetServerEnabledRequest) (*SetServerEnabledResponse, error)
	// Update balena server information
	Update(context.Context, *UpdateServerRequest) (*UpdateServerResponse, error)
	// Delete balena server
	Delete(context.Context, *DeleteServerRequest) (*DeleteServerResponse, error)
	mustEmbedUnimplementedBalenaServersServiceServer()
}

// UnimplementedBalenaServersServiceServer must be embedded to have forward compatible implementations.
type UnimplementedBalenaServersServiceServer struct {
}

func (UnimplementedBalenaServersServiceServer) Create(context.Context, *CreateServerRequest) (*CreateServerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedBalenaServersServiceServer) Get(context.Context, *GetServerRequest) (*GetServerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedBalenaServersServiceServer) List(*ListServersRequest, BalenaServersService_ListServer) error {
	return status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedBalenaServersServiceServer) Count(context.Context, *CountServersRequest) (*CountServersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Count not implemented")
}
func (UnimplementedBalenaServersServiceServer) ListInNamespace(*ListServersInNamespaceRequest, BalenaServersService_ListInNamespaceServer) error {
	return status.Errorf(codes.Unimplemented, "method ListInNamespace not implemented")
}
func (UnimplementedBalenaServersServiceServer) CountInNamespace(context.Context, *CountServersInNamespaceRequest) (*CountServersInNamespaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountInNamespace not implemented")
}
func (UnimplementedBalenaServersServiceServer) SetEnabled(context.Context, *SetServerEnabledRequest) (*SetServerEnabledResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetEnabled not implemented")
}
func (UnimplementedBalenaServersServiceServer) Update(context.Context, *UpdateServerRequest) (*UpdateServerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedBalenaServersServiceServer) Delete(context.Context, *DeleteServerRequest) (*DeleteServerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedBalenaServersServiceServer) mustEmbedUnimplementedBalenaServersServiceServer() {}

// UnsafeBalenaServersServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BalenaServersServiceServer will
// result in compilation errors.
type UnsafeBalenaServersServiceServer interface {
	mustEmbedUnimplementedBalenaServersServiceServer()
}

func RegisterBalenaServersServiceServer(s grpc.ServiceRegistrar, srv BalenaServersServiceServer) {
	s.RegisterService(&BalenaServersService_ServiceDesc, srv)
}

func _BalenaServersService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BalenaServersServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iot_core_integration_balena.BalenaServersService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BalenaServersServiceServer).Create(ctx, req.(*CreateServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BalenaServersService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BalenaServersServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iot_core_integration_balena.BalenaServersService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BalenaServersServiceServer).Get(ctx, req.(*GetServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BalenaServersService_List_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListServersRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BalenaServersServiceServer).List(m, &balenaServersServiceListServer{stream})
}

type BalenaServersService_ListServer interface {
	Send(*ListServersResponse) error
	grpc.ServerStream
}

type balenaServersServiceListServer struct {
	grpc.ServerStream
}

func (x *balenaServersServiceListServer) Send(m *ListServersResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _BalenaServersService_Count_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountServersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BalenaServersServiceServer).Count(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iot_core_integration_balena.BalenaServersService/Count",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BalenaServersServiceServer).Count(ctx, req.(*CountServersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BalenaServersService_ListInNamespace_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListServersInNamespaceRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BalenaServersServiceServer).ListInNamespace(m, &balenaServersServiceListInNamespaceServer{stream})
}

type BalenaServersService_ListInNamespaceServer interface {
	Send(*ListServersInNamespaceResponse) error
	grpc.ServerStream
}

type balenaServersServiceListInNamespaceServer struct {
	grpc.ServerStream
}

func (x *balenaServersServiceListInNamespaceServer) Send(m *ListServersInNamespaceResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _BalenaServersService_CountInNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountServersInNamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BalenaServersServiceServer).CountInNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iot_core_integration_balena.BalenaServersService/CountInNamespace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BalenaServersServiceServer).CountInNamespace(ctx, req.(*CountServersInNamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BalenaServersService_SetEnabled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetServerEnabledRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BalenaServersServiceServer).SetEnabled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iot_core_integration_balena.BalenaServersService/SetEnabled",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BalenaServersServiceServer).SetEnabled(ctx, req.(*SetServerEnabledRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BalenaServersService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BalenaServersServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iot_core_integration_balena.BalenaServersService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BalenaServersServiceServer).Update(ctx, req.(*UpdateServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BalenaServersService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BalenaServersServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iot_core_integration_balena.BalenaServersService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BalenaServersServiceServer).Delete(ctx, req.(*DeleteServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BalenaServersService_ServiceDesc is the grpc.ServiceDesc for BalenaServersService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BalenaServersService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "iot_core_integration_balena.BalenaServersService",
	HandlerType: (*BalenaServersServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _BalenaServersService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _BalenaServersService_Get_Handler,
		},
		{
			MethodName: "Count",
			Handler:    _BalenaServersService_Count_Handler,
		},
		{
			MethodName: "CountInNamespace",
			Handler:    _BalenaServersService_CountInNamespace_Handler,
		},
		{
			MethodName: "SetEnabled",
			Handler:    _BalenaServersService_SetEnabled_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _BalenaServersService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _BalenaServersService_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "List",
			Handler:       _BalenaServersService_List_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListInNamespace",
			Handler:       _BalenaServersService_ListInNamespace_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "balena.proto",
}

// BalenaToolsServiceClient is the client API for BalenaToolsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BalenaToolsServiceClient interface {
	// Verify provided connection data. Make request to the remote server and check if it responses as expected.
	VerifyConnectionData(ctx context.Context, in *VerifyConnectionDataRequest, opts ...grpc.CallOption) (*VerifyConnectionDataResponse, error)
}

type balenaToolsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBalenaToolsServiceClient(cc grpc.ClientConnInterface) BalenaToolsServiceClient {
	return &balenaToolsServiceClient{cc}
}

func (c *balenaToolsServiceClient) VerifyConnectionData(ctx context.Context, in *VerifyConnectionDataRequest, opts ...grpc.CallOption) (*VerifyConnectionDataResponse, error) {
	out := new(VerifyConnectionDataResponse)
	err := c.cc.Invoke(ctx, "/iot_core_integration_balena.BalenaToolsService/VerifyConnectionData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BalenaToolsServiceServer is the server API for BalenaToolsService service.
// All implementations must embed UnimplementedBalenaToolsServiceServer
// for forward compatibility
type BalenaToolsServiceServer interface {
	// Verify provided connection data. Make request to the remote server and check if it responses as expected.
	VerifyConnectionData(context.Context, *VerifyConnectionDataRequest) (*VerifyConnectionDataResponse, error)
	mustEmbedUnimplementedBalenaToolsServiceServer()
}

// UnimplementedBalenaToolsServiceServer must be embedded to have forward compatible implementations.
type UnimplementedBalenaToolsServiceServer struct {
}

func (UnimplementedBalenaToolsServiceServer) VerifyConnectionData(context.Context, *VerifyConnectionDataRequest) (*VerifyConnectionDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyConnectionData not implemented")
}
func (UnimplementedBalenaToolsServiceServer) mustEmbedUnimplementedBalenaToolsServiceServer() {}

// UnsafeBalenaToolsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BalenaToolsServiceServer will
// result in compilation errors.
type UnsafeBalenaToolsServiceServer interface {
	mustEmbedUnimplementedBalenaToolsServiceServer()
}

func RegisterBalenaToolsServiceServer(s grpc.ServiceRegistrar, srv BalenaToolsServiceServer) {
	s.RegisterService(&BalenaToolsService_ServiceDesc, srv)
}

func _BalenaToolsService_VerifyConnectionData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyConnectionDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BalenaToolsServiceServer).VerifyConnectionData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iot_core_integration_balena.BalenaToolsService/VerifyConnectionData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BalenaToolsServiceServer).VerifyConnectionData(ctx, req.(*VerifyConnectionDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BalenaToolsService_ServiceDesc is the grpc.ServiceDesc for BalenaToolsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BalenaToolsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "iot_core_integration_balena.BalenaToolsService",
	HandlerType: (*BalenaToolsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "VerifyConnectionData",
			Handler:    _BalenaToolsService_VerifyConnectionData_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "balena.proto",
}

// BalenaDevicesServiceClient is the client API for BalenaDevicesService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BalenaDevicesServiceClient interface {
	// Bind Balena device to the OpenBP IoT device
	Bind(ctx context.Context, in *BindDeviceRequest, opts ...grpc.CallOption) (*BindDeviceResponse, error)
	// Unbind OpenBP device from the Balena device
	UnBind(ctx context.Context, in *UnBindDeviceRequest, opts ...grpc.CallOption) (*UnBindDeviceResponse, error)
	// List all the Balena devices in namespace
	ListInNamespace(ctx context.Context, in *ListDevicesInNamespaceRequest, opts ...grpc.CallOption) (BalenaDevicesService_ListInNamespaceClient, error)
	// Count all the Balena devices in namespace
	CountInNamespace(ctx context.Context, in *CountDevicesInNamespaceRequest, opts ...grpc.CallOption) (*CountDevicesInNamespaceResponse, error)
}

type balenaDevicesServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBalenaDevicesServiceClient(cc grpc.ClientConnInterface) BalenaDevicesServiceClient {
	return &balenaDevicesServiceClient{cc}
}

func (c *balenaDevicesServiceClient) Bind(ctx context.Context, in *BindDeviceRequest, opts ...grpc.CallOption) (*BindDeviceResponse, error) {
	out := new(BindDeviceResponse)
	err := c.cc.Invoke(ctx, "/iot_core_integration_balena.BalenaDevicesService/Bind", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *balenaDevicesServiceClient) UnBind(ctx context.Context, in *UnBindDeviceRequest, opts ...grpc.CallOption) (*UnBindDeviceResponse, error) {
	out := new(UnBindDeviceResponse)
	err := c.cc.Invoke(ctx, "/iot_core_integration_balena.BalenaDevicesService/UnBind", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *balenaDevicesServiceClient) ListInNamespace(ctx context.Context, in *ListDevicesInNamespaceRequest, opts ...grpc.CallOption) (BalenaDevicesService_ListInNamespaceClient, error) {
	stream, err := c.cc.NewStream(ctx, &BalenaDevicesService_ServiceDesc.Streams[0], "/iot_core_integration_balena.BalenaDevicesService/ListInNamespace", opts...)
	if err != nil {
		return nil, err
	}
	x := &balenaDevicesServiceListInNamespaceClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BalenaDevicesService_ListInNamespaceClient interface {
	Recv() (*ListDevicesInNamespaceResponse, error)
	grpc.ClientStream
}

type balenaDevicesServiceListInNamespaceClient struct {
	grpc.ClientStream
}

func (x *balenaDevicesServiceListInNamespaceClient) Recv() (*ListDevicesInNamespaceResponse, error) {
	m := new(ListDevicesInNamespaceResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *balenaDevicesServiceClient) CountInNamespace(ctx context.Context, in *CountDevicesInNamespaceRequest, opts ...grpc.CallOption) (*CountDevicesInNamespaceResponse, error) {
	out := new(CountDevicesInNamespaceResponse)
	err := c.cc.Invoke(ctx, "/iot_core_integration_balena.BalenaDevicesService/CountInNamespace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BalenaDevicesServiceServer is the server API for BalenaDevicesService service.
// All implementations must embed UnimplementedBalenaDevicesServiceServer
// for forward compatibility
type BalenaDevicesServiceServer interface {
	// Bind Balena device to the OpenBP IoT device
	Bind(context.Context, *BindDeviceRequest) (*BindDeviceResponse, error)
	// Unbind OpenBP device from the Balena device
	UnBind(context.Context, *UnBindDeviceRequest) (*UnBindDeviceResponse, error)
	// List all the Balena devices in namespace
	ListInNamespace(*ListDevicesInNamespaceRequest, BalenaDevicesService_ListInNamespaceServer) error
	// Count all the Balena devices in namespace
	CountInNamespace(context.Context, *CountDevicesInNamespaceRequest) (*CountDevicesInNamespaceResponse, error)
	mustEmbedUnimplementedBalenaDevicesServiceServer()
}

// UnimplementedBalenaDevicesServiceServer must be embedded to have forward compatible implementations.
type UnimplementedBalenaDevicesServiceServer struct {
}

func (UnimplementedBalenaDevicesServiceServer) Bind(context.Context, *BindDeviceRequest) (*BindDeviceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Bind not implemented")
}
func (UnimplementedBalenaDevicesServiceServer) UnBind(context.Context, *UnBindDeviceRequest) (*UnBindDeviceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnBind not implemented")
}
func (UnimplementedBalenaDevicesServiceServer) ListInNamespace(*ListDevicesInNamespaceRequest, BalenaDevicesService_ListInNamespaceServer) error {
	return status.Errorf(codes.Unimplemented, "method ListInNamespace not implemented")
}
func (UnimplementedBalenaDevicesServiceServer) CountInNamespace(context.Context, *CountDevicesInNamespaceRequest) (*CountDevicesInNamespaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountInNamespace not implemented")
}
func (UnimplementedBalenaDevicesServiceServer) mustEmbedUnimplementedBalenaDevicesServiceServer() {}

// UnsafeBalenaDevicesServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BalenaDevicesServiceServer will
// result in compilation errors.
type UnsafeBalenaDevicesServiceServer interface {
	mustEmbedUnimplementedBalenaDevicesServiceServer()
}

func RegisterBalenaDevicesServiceServer(s grpc.ServiceRegistrar, srv BalenaDevicesServiceServer) {
	s.RegisterService(&BalenaDevicesService_ServiceDesc, srv)
}

func _BalenaDevicesService_Bind_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BindDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BalenaDevicesServiceServer).Bind(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iot_core_integration_balena.BalenaDevicesService/Bind",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BalenaDevicesServiceServer).Bind(ctx, req.(*BindDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BalenaDevicesService_UnBind_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnBindDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BalenaDevicesServiceServer).UnBind(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iot_core_integration_balena.BalenaDevicesService/UnBind",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BalenaDevicesServiceServer).UnBind(ctx, req.(*UnBindDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BalenaDevicesService_ListInNamespace_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListDevicesInNamespaceRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BalenaDevicesServiceServer).ListInNamespace(m, &balenaDevicesServiceListInNamespaceServer{stream})
}

type BalenaDevicesService_ListInNamespaceServer interface {
	Send(*ListDevicesInNamespaceResponse) error
	grpc.ServerStream
}

type balenaDevicesServiceListInNamespaceServer struct {
	grpc.ServerStream
}

func (x *balenaDevicesServiceListInNamespaceServer) Send(m *ListDevicesInNamespaceResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _BalenaDevicesService_CountInNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountDevicesInNamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BalenaDevicesServiceServer).CountInNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iot_core_integration_balena.BalenaDevicesService/CountInNamespace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BalenaDevicesServiceServer).CountInNamespace(ctx, req.(*CountDevicesInNamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BalenaDevicesService_ServiceDesc is the grpc.ServiceDesc for BalenaDevicesService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BalenaDevicesService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "iot_core_integration_balena.BalenaDevicesService",
	HandlerType: (*BalenaDevicesServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Bind",
			Handler:    _BalenaDevicesService_Bind_Handler,
		},
		{
			MethodName: "UnBind",
			Handler:    _BalenaDevicesService_UnBind_Handler,
		},
		{
			MethodName: "CountInNamespace",
			Handler:    _BalenaDevicesService_CountInNamespace_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListInNamespace",
			Handler:       _BalenaDevicesService_ListInNamespace_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "balena.proto",
}

// BalenaSyncServiceClient is the client API for BalenaSyncService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BalenaSyncServiceClient interface {
	// Synchronize the state between Balena server and OpenBP. Start synchronization immediatelly
	SyncNow(ctx context.Context, in *SyncNowRequest, opts ...grpc.CallOption) (*SyncNowResponse, error)
	// List synchronization log
	ListLog(ctx context.Context, in *ListSyncLogRequest, opts ...grpc.CallOption) (BalenaSyncService_ListLogClient, error)
	// Count number of entries in the synchronization log
	CountLog(ctx context.Context, in *CountSyncLogRequest, opts ...grpc.CallOption) (*CountSyncLogResponse, error)
	// Get last synchronization log for server
	GetLastSyncLog(ctx context.Context, in *GetLastSyncLogRequest, opts ...grpc.CallOption) (*GetLastSyncLogResponse, error)
}

type balenaSyncServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBalenaSyncServiceClient(cc grpc.ClientConnInterface) BalenaSyncServiceClient {
	return &balenaSyncServiceClient{cc}
}

func (c *balenaSyncServiceClient) SyncNow(ctx context.Context, in *SyncNowRequest, opts ...grpc.CallOption) (*SyncNowResponse, error) {
	out := new(SyncNowResponse)
	err := c.cc.Invoke(ctx, "/iot_core_integration_balena.BalenaSyncService/SyncNow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *balenaSyncServiceClient) ListLog(ctx context.Context, in *ListSyncLogRequest, opts ...grpc.CallOption) (BalenaSyncService_ListLogClient, error) {
	stream, err := c.cc.NewStream(ctx, &BalenaSyncService_ServiceDesc.Streams[0], "/iot_core_integration_balena.BalenaSyncService/ListLog", opts...)
	if err != nil {
		return nil, err
	}
	x := &balenaSyncServiceListLogClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BalenaSyncService_ListLogClient interface {
	Recv() (*ListSyncLogResponse, error)
	grpc.ClientStream
}

type balenaSyncServiceListLogClient struct {
	grpc.ClientStream
}

func (x *balenaSyncServiceListLogClient) Recv() (*ListSyncLogResponse, error) {
	m := new(ListSyncLogResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *balenaSyncServiceClient) CountLog(ctx context.Context, in *CountSyncLogRequest, opts ...grpc.CallOption) (*CountSyncLogResponse, error) {
	out := new(CountSyncLogResponse)
	err := c.cc.Invoke(ctx, "/iot_core_integration_balena.BalenaSyncService/CountLog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *balenaSyncServiceClient) GetLastSyncLog(ctx context.Context, in *GetLastSyncLogRequest, opts ...grpc.CallOption) (*GetLastSyncLogResponse, error) {
	out := new(GetLastSyncLogResponse)
	err := c.cc.Invoke(ctx, "/iot_core_integration_balena.BalenaSyncService/GetLastSyncLog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BalenaSyncServiceServer is the server API for BalenaSyncService service.
// All implementations must embed UnimplementedBalenaSyncServiceServer
// for forward compatibility
type BalenaSyncServiceServer interface {
	// Synchronize the state between Balena server and OpenBP. Start synchronization immediatelly
	SyncNow(context.Context, *SyncNowRequest) (*SyncNowResponse, error)
	// List synchronization log
	ListLog(*ListSyncLogRequest, BalenaSyncService_ListLogServer) error
	// Count number of entries in the synchronization log
	CountLog(context.Context, *CountSyncLogRequest) (*CountSyncLogResponse, error)
	// Get last synchronization log for server
	GetLastSyncLog(context.Context, *GetLastSyncLogRequest) (*GetLastSyncLogResponse, error)
	mustEmbedUnimplementedBalenaSyncServiceServer()
}

// UnimplementedBalenaSyncServiceServer must be embedded to have forward compatible implementations.
type UnimplementedBalenaSyncServiceServer struct {
}

func (UnimplementedBalenaSyncServiceServer) SyncNow(context.Context, *SyncNowRequest) (*SyncNowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncNow not implemented")
}
func (UnimplementedBalenaSyncServiceServer) ListLog(*ListSyncLogRequest, BalenaSyncService_ListLogServer) error {
	return status.Errorf(codes.Unimplemented, "method ListLog not implemented")
}
func (UnimplementedBalenaSyncServiceServer) CountLog(context.Context, *CountSyncLogRequest) (*CountSyncLogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountLog not implemented")
}
func (UnimplementedBalenaSyncServiceServer) GetLastSyncLog(context.Context, *GetLastSyncLogRequest) (*GetLastSyncLogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLastSyncLog not implemented")
}
func (UnimplementedBalenaSyncServiceServer) mustEmbedUnimplementedBalenaSyncServiceServer() {}

// UnsafeBalenaSyncServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BalenaSyncServiceServer will
// result in compilation errors.
type UnsafeBalenaSyncServiceServer interface {
	mustEmbedUnimplementedBalenaSyncServiceServer()
}

func RegisterBalenaSyncServiceServer(s grpc.ServiceRegistrar, srv BalenaSyncServiceServer) {
	s.RegisterService(&BalenaSyncService_ServiceDesc, srv)
}

func _BalenaSyncService_SyncNow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncNowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BalenaSyncServiceServer).SyncNow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iot_core_integration_balena.BalenaSyncService/SyncNow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BalenaSyncServiceServer).SyncNow(ctx, req.(*SyncNowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BalenaSyncService_ListLog_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListSyncLogRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BalenaSyncServiceServer).ListLog(m, &balenaSyncServiceListLogServer{stream})
}

type BalenaSyncService_ListLogServer interface {
	Send(*ListSyncLogResponse) error
	grpc.ServerStream
}

type balenaSyncServiceListLogServer struct {
	grpc.ServerStream
}

func (x *balenaSyncServiceListLogServer) Send(m *ListSyncLogResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _BalenaSyncService_CountLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountSyncLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BalenaSyncServiceServer).CountLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iot_core_integration_balena.BalenaSyncService/CountLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BalenaSyncServiceServer).CountLog(ctx, req.(*CountSyncLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BalenaSyncService_GetLastSyncLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLastSyncLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BalenaSyncServiceServer).GetLastSyncLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iot_core_integration_balena.BalenaSyncService/GetLastSyncLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BalenaSyncServiceServer).GetLastSyncLog(ctx, req.(*GetLastSyncLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BalenaSyncService_ServiceDesc is the grpc.ServiceDesc for BalenaSyncService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BalenaSyncService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "iot_core_integration_balena.BalenaSyncService",
	HandlerType: (*BalenaSyncServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SyncNow",
			Handler:    _BalenaSyncService_SyncNow_Handler,
		},
		{
			MethodName: "CountLog",
			Handler:    _BalenaSyncService_CountLog_Handler,
		},
		{
			MethodName: "GetLastSyncLog",
			Handler:    _BalenaSyncService_GetLastSyncLog_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListLog",
			Handler:       _BalenaSyncService_ListLog_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "balena.proto",
}
