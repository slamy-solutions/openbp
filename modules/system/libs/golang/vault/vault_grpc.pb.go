// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.12.4
// source: vault.proto

package vault

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// VaultServiceClient is the client API for VaultService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VaultServiceClient interface {
	// Closes and encrypts vault. After sealing, most of the operations will not be accessible.
	Seal(ctx context.Context, in *SealRequest, opts ...grpc.CallOption) (*SealResponse, error)
	// Decrypts and opens vault. Must be done before most of the operations with vault secrets.
	Unseal(ctx context.Context, in *UnsealRequest, opts ...grpc.CallOption) (*UnsealResponse, error)
	// Set up new seal secret and reincrypt vault. The vault must be unsealed before this operation.
	UpdateSealSecret(ctx context.Context, in *UpdateSealSecretRequest, opts ...grpc.CallOption) (*UpdateSealSecretResponse, error)
	// Returns current status of the vault.
	GetStatus(ctx context.Context, in *GetStatusRequest, opts ...grpc.CallOption) (*GetStatusResponse, error)
	// Creates RSA key pair if it doesnt exist. Private key never leaves the HSM (hardware security module).
	EnsureRSAKeyPair(ctx context.Context, in *EnsureRSAKeyPairRequest, opts ...grpc.CallOption) (*EnsureRSAKeyPairResponse, error)
	// Get public key of the RSA keypair.
	GetRSAPublicKey(ctx context.Context, in *GetRSAPublicKeyRequest, opts ...grpc.CallOption) (*GetRSAPublicKeyResponse, error)
	// Sign message with RSA. It will use SHA512_RSA_PKCS (RS512) algorithm to sing the message.
	RSASign(ctx context.Context, opts ...grpc.CallOption) (VaultService_RSASignClient, error)
	// Validate signature of the message using RSA key-pairs public key. It will use SHA512_RSA_PKCS (RS512) algorithm to verify the message.
	RSAVerify(ctx context.Context, opts ...grpc.CallOption) (VaultService_RSAVerifyClient, error)
	// Calculates HMAC signature for input data. HMAC secret never leaves the HSM (hardware security module). It automatically uses the best available HMAC algorithm for currently used HSM.
	HMACSign(ctx context.Context, opts ...grpc.CallOption) (VaultService_HMACSignClient, error)
	// Verifies HMAC signature of the data.
	HMACVerify(ctx context.Context, opts ...grpc.CallOption) (VaultService_HMACVerifyClient, error)
	// Encrypts message. Encryption secret never leaves the HSM (hardware security module). It automatically uses the best available encryption algorithm for currently used HSM. It will only select the algorithm that is capable ofdecrypting from the middle of the whole data (partial decryption).
	Encrypt(ctx context.Context, opts ...grpc.CallOption) (VaultService_EncryptClient, error)
	// Decrypts message. If you want to decrypt part of the information from the middle of the whole data - ensure, that the first chunk of the data, that you are sending is padded by 2048 bit.
	Decrypt(ctx context.Context, opts ...grpc.CallOption) (VaultService_DecryptClient, error)
}

type vaultServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVaultServiceClient(cc grpc.ClientConnInterface) VaultServiceClient {
	return &vaultServiceClient{cc}
}

func (c *vaultServiceClient) Seal(ctx context.Context, in *SealRequest, opts ...grpc.CallOption) (*SealResponse, error) {
	out := new(SealResponse)
	err := c.cc.Invoke(ctx, "/system_vault.VaultService/Seal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) Unseal(ctx context.Context, in *UnsealRequest, opts ...grpc.CallOption) (*UnsealResponse, error) {
	out := new(UnsealResponse)
	err := c.cc.Invoke(ctx, "/system_vault.VaultService/Unseal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) UpdateSealSecret(ctx context.Context, in *UpdateSealSecretRequest, opts ...grpc.CallOption) (*UpdateSealSecretResponse, error) {
	out := new(UpdateSealSecretResponse)
	err := c.cc.Invoke(ctx, "/system_vault.VaultService/UpdateSealSecret", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) GetStatus(ctx context.Context, in *GetStatusRequest, opts ...grpc.CallOption) (*GetStatusResponse, error) {
	out := new(GetStatusResponse)
	err := c.cc.Invoke(ctx, "/system_vault.VaultService/GetStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) EnsureRSAKeyPair(ctx context.Context, in *EnsureRSAKeyPairRequest, opts ...grpc.CallOption) (*EnsureRSAKeyPairResponse, error) {
	out := new(EnsureRSAKeyPairResponse)
	err := c.cc.Invoke(ctx, "/system_vault.VaultService/EnsureRSAKeyPair", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) GetRSAPublicKey(ctx context.Context, in *GetRSAPublicKeyRequest, opts ...grpc.CallOption) (*GetRSAPublicKeyResponse, error) {
	out := new(GetRSAPublicKeyResponse)
	err := c.cc.Invoke(ctx, "/system_vault.VaultService/GetRSAPublicKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) RSASign(ctx context.Context, opts ...grpc.CallOption) (VaultService_RSASignClient, error) {
	stream, err := c.cc.NewStream(ctx, &VaultService_ServiceDesc.Streams[0], "/system_vault.VaultService/RSASign", opts...)
	if err != nil {
		return nil, err
	}
	x := &vaultServiceRSASignClient{stream}
	return x, nil
}

type VaultService_RSASignClient interface {
	Send(*RSASignRequest) error
	CloseAndRecv() (*RSASignResponse, error)
	grpc.ClientStream
}

type vaultServiceRSASignClient struct {
	grpc.ClientStream
}

func (x *vaultServiceRSASignClient) Send(m *RSASignRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *vaultServiceRSASignClient) CloseAndRecv() (*RSASignResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(RSASignResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vaultServiceClient) RSAVerify(ctx context.Context, opts ...grpc.CallOption) (VaultService_RSAVerifyClient, error) {
	stream, err := c.cc.NewStream(ctx, &VaultService_ServiceDesc.Streams[1], "/system_vault.VaultService/RSAVerify", opts...)
	if err != nil {
		return nil, err
	}
	x := &vaultServiceRSAVerifyClient{stream}
	return x, nil
}

type VaultService_RSAVerifyClient interface {
	Send(*RSAVerifyRequest) error
	CloseAndRecv() (*RSAVerifyResponse, error)
	grpc.ClientStream
}

type vaultServiceRSAVerifyClient struct {
	grpc.ClientStream
}

func (x *vaultServiceRSAVerifyClient) Send(m *RSAVerifyRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *vaultServiceRSAVerifyClient) CloseAndRecv() (*RSAVerifyResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(RSAVerifyResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vaultServiceClient) HMACSign(ctx context.Context, opts ...grpc.CallOption) (VaultService_HMACSignClient, error) {
	stream, err := c.cc.NewStream(ctx, &VaultService_ServiceDesc.Streams[2], "/system_vault.VaultService/HMACSign", opts...)
	if err != nil {
		return nil, err
	}
	x := &vaultServiceHMACSignClient{stream}
	return x, nil
}

type VaultService_HMACSignClient interface {
	Send(*HMACSignRequest) error
	CloseAndRecv() (*HMACSignResponse, error)
	grpc.ClientStream
}

type vaultServiceHMACSignClient struct {
	grpc.ClientStream
}

func (x *vaultServiceHMACSignClient) Send(m *HMACSignRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *vaultServiceHMACSignClient) CloseAndRecv() (*HMACSignResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(HMACSignResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vaultServiceClient) HMACVerify(ctx context.Context, opts ...grpc.CallOption) (VaultService_HMACVerifyClient, error) {
	stream, err := c.cc.NewStream(ctx, &VaultService_ServiceDesc.Streams[3], "/system_vault.VaultService/HMACVerify", opts...)
	if err != nil {
		return nil, err
	}
	x := &vaultServiceHMACVerifyClient{stream}
	return x, nil
}

type VaultService_HMACVerifyClient interface {
	Send(*HMACVerifyRequest) error
	CloseAndRecv() (*HMACVerifyResponse, error)
	grpc.ClientStream
}

type vaultServiceHMACVerifyClient struct {
	grpc.ClientStream
}

func (x *vaultServiceHMACVerifyClient) Send(m *HMACVerifyRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *vaultServiceHMACVerifyClient) CloseAndRecv() (*HMACVerifyResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(HMACVerifyResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vaultServiceClient) Encrypt(ctx context.Context, opts ...grpc.CallOption) (VaultService_EncryptClient, error) {
	stream, err := c.cc.NewStream(ctx, &VaultService_ServiceDesc.Streams[4], "/system_vault.VaultService/Encrypt", opts...)
	if err != nil {
		return nil, err
	}
	x := &vaultServiceEncryptClient{stream}
	return x, nil
}

type VaultService_EncryptClient interface {
	Send(*EncryptRequest) error
	Recv() (*EncryptResponse, error)
	grpc.ClientStream
}

type vaultServiceEncryptClient struct {
	grpc.ClientStream
}

func (x *vaultServiceEncryptClient) Send(m *EncryptRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *vaultServiceEncryptClient) Recv() (*EncryptResponse, error) {
	m := new(EncryptResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vaultServiceClient) Decrypt(ctx context.Context, opts ...grpc.CallOption) (VaultService_DecryptClient, error) {
	stream, err := c.cc.NewStream(ctx, &VaultService_ServiceDesc.Streams[5], "/system_vault.VaultService/Decrypt", opts...)
	if err != nil {
		return nil, err
	}
	x := &vaultServiceDecryptClient{stream}
	return x, nil
}

type VaultService_DecryptClient interface {
	Send(*DecryptRequest) error
	Recv() (*DecryptResponse, error)
	grpc.ClientStream
}

type vaultServiceDecryptClient struct {
	grpc.ClientStream
}

func (x *vaultServiceDecryptClient) Send(m *DecryptRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *vaultServiceDecryptClient) Recv() (*DecryptResponse, error) {
	m := new(DecryptResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// VaultServiceServer is the server API for VaultService service.
// All implementations must embed UnimplementedVaultServiceServer
// for forward compatibility
type VaultServiceServer interface {
	// Closes and encrypts vault. After sealing, most of the operations will not be accessible.
	Seal(context.Context, *SealRequest) (*SealResponse, error)
	// Decrypts and opens vault. Must be done before most of the operations with vault secrets.
	Unseal(context.Context, *UnsealRequest) (*UnsealResponse, error)
	// Set up new seal secret and reincrypt vault. The vault must be unsealed before this operation.
	UpdateSealSecret(context.Context, *UpdateSealSecretRequest) (*UpdateSealSecretResponse, error)
	// Returns current status of the vault.
	GetStatus(context.Context, *GetStatusRequest) (*GetStatusResponse, error)
	// Creates RSA key pair if it doesnt exist. Private key never leaves the HSM (hardware security module).
	EnsureRSAKeyPair(context.Context, *EnsureRSAKeyPairRequest) (*EnsureRSAKeyPairResponse, error)
	// Get public key of the RSA keypair.
	GetRSAPublicKey(context.Context, *GetRSAPublicKeyRequest) (*GetRSAPublicKeyResponse, error)
	// Sign message with RSA. It will use SHA512_RSA_PKCS (RS512) algorithm to sing the message.
	RSASign(VaultService_RSASignServer) error
	// Validate signature of the message using RSA key-pairs public key. It will use SHA512_RSA_PKCS (RS512) algorithm to verify the message.
	RSAVerify(VaultService_RSAVerifyServer) error
	// Calculates HMAC signature for input data. HMAC secret never leaves the HSM (hardware security module). It automatically uses the best available HMAC algorithm for currently used HSM.
	HMACSign(VaultService_HMACSignServer) error
	// Verifies HMAC signature of the data.
	HMACVerify(VaultService_HMACVerifyServer) error
	// Encrypts message. Encryption secret never leaves the HSM (hardware security module). It automatically uses the best available encryption algorithm for currently used HSM. It will only select the algorithm that is capable ofdecrypting from the middle of the whole data (partial decryption).
	Encrypt(VaultService_EncryptServer) error
	// Decrypts message. If you want to decrypt part of the information from the middle of the whole data - ensure, that the first chunk of the data, that you are sending is padded by 2048 bit.
	Decrypt(VaultService_DecryptServer) error
	mustEmbedUnimplementedVaultServiceServer()
}

// UnimplementedVaultServiceServer must be embedded to have forward compatible implementations.
type UnimplementedVaultServiceServer struct {
}

func (UnimplementedVaultServiceServer) Seal(context.Context, *SealRequest) (*SealResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Seal not implemented")
}
func (UnimplementedVaultServiceServer) Unseal(context.Context, *UnsealRequest) (*UnsealResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unseal not implemented")
}
func (UnimplementedVaultServiceServer) UpdateSealSecret(context.Context, *UpdateSealSecretRequest) (*UpdateSealSecretResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSealSecret not implemented")
}
func (UnimplementedVaultServiceServer) GetStatus(context.Context, *GetStatusRequest) (*GetStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStatus not implemented")
}
func (UnimplementedVaultServiceServer) EnsureRSAKeyPair(context.Context, *EnsureRSAKeyPairRequest) (*EnsureRSAKeyPairResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnsureRSAKeyPair not implemented")
}
func (UnimplementedVaultServiceServer) GetRSAPublicKey(context.Context, *GetRSAPublicKeyRequest) (*GetRSAPublicKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRSAPublicKey not implemented")
}
func (UnimplementedVaultServiceServer) RSASign(VaultService_RSASignServer) error {
	return status.Errorf(codes.Unimplemented, "method RSASign not implemented")
}
func (UnimplementedVaultServiceServer) RSAVerify(VaultService_RSAVerifyServer) error {
	return status.Errorf(codes.Unimplemented, "method RSAVerify not implemented")
}
func (UnimplementedVaultServiceServer) HMACSign(VaultService_HMACSignServer) error {
	return status.Errorf(codes.Unimplemented, "method HMACSign not implemented")
}
func (UnimplementedVaultServiceServer) HMACVerify(VaultService_HMACVerifyServer) error {
	return status.Errorf(codes.Unimplemented, "method HMACVerify not implemented")
}
func (UnimplementedVaultServiceServer) Encrypt(VaultService_EncryptServer) error {
	return status.Errorf(codes.Unimplemented, "method Encrypt not implemented")
}
func (UnimplementedVaultServiceServer) Decrypt(VaultService_DecryptServer) error {
	return status.Errorf(codes.Unimplemented, "method Decrypt not implemented")
}
func (UnimplementedVaultServiceServer) mustEmbedUnimplementedVaultServiceServer() {}

// UnsafeVaultServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VaultServiceServer will
// result in compilation errors.
type UnsafeVaultServiceServer interface {
	mustEmbedUnimplementedVaultServiceServer()
}

func RegisterVaultServiceServer(s grpc.ServiceRegistrar, srv VaultServiceServer) {
	s.RegisterService(&VaultService_ServiceDesc, srv)
}

func _VaultService_Seal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SealRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VaultServiceServer).Seal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/system_vault.VaultService/Seal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VaultServiceServer).Seal(ctx, req.(*SealRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VaultService_Unseal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnsealRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VaultServiceServer).Unseal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/system_vault.VaultService/Unseal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VaultServiceServer).Unseal(ctx, req.(*UnsealRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VaultService_UpdateSealSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSealSecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VaultServiceServer).UpdateSealSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/system_vault.VaultService/UpdateSealSecret",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VaultServiceServer).UpdateSealSecret(ctx, req.(*UpdateSealSecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VaultService_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VaultServiceServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/system_vault.VaultService/GetStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VaultServiceServer).GetStatus(ctx, req.(*GetStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VaultService_EnsureRSAKeyPair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnsureRSAKeyPairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VaultServiceServer).EnsureRSAKeyPair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/system_vault.VaultService/EnsureRSAKeyPair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VaultServiceServer).EnsureRSAKeyPair(ctx, req.(*EnsureRSAKeyPairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VaultService_GetRSAPublicKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRSAPublicKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VaultServiceServer).GetRSAPublicKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/system_vault.VaultService/GetRSAPublicKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VaultServiceServer).GetRSAPublicKey(ctx, req.(*GetRSAPublicKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VaultService_RSASign_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(VaultServiceServer).RSASign(&vaultServiceRSASignServer{stream})
}

type VaultService_RSASignServer interface {
	SendAndClose(*RSASignResponse) error
	Recv() (*RSASignRequest, error)
	grpc.ServerStream
}

type vaultServiceRSASignServer struct {
	grpc.ServerStream
}

func (x *vaultServiceRSASignServer) SendAndClose(m *RSASignResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *vaultServiceRSASignServer) Recv() (*RSASignRequest, error) {
	m := new(RSASignRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _VaultService_RSAVerify_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(VaultServiceServer).RSAVerify(&vaultServiceRSAVerifyServer{stream})
}

type VaultService_RSAVerifyServer interface {
	SendAndClose(*RSAVerifyResponse) error
	Recv() (*RSAVerifyRequest, error)
	grpc.ServerStream
}

type vaultServiceRSAVerifyServer struct {
	grpc.ServerStream
}

func (x *vaultServiceRSAVerifyServer) SendAndClose(m *RSAVerifyResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *vaultServiceRSAVerifyServer) Recv() (*RSAVerifyRequest, error) {
	m := new(RSAVerifyRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _VaultService_HMACSign_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(VaultServiceServer).HMACSign(&vaultServiceHMACSignServer{stream})
}

type VaultService_HMACSignServer interface {
	SendAndClose(*HMACSignResponse) error
	Recv() (*HMACSignRequest, error)
	grpc.ServerStream
}

type vaultServiceHMACSignServer struct {
	grpc.ServerStream
}

func (x *vaultServiceHMACSignServer) SendAndClose(m *HMACSignResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *vaultServiceHMACSignServer) Recv() (*HMACSignRequest, error) {
	m := new(HMACSignRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _VaultService_HMACVerify_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(VaultServiceServer).HMACVerify(&vaultServiceHMACVerifyServer{stream})
}

type VaultService_HMACVerifyServer interface {
	SendAndClose(*HMACVerifyResponse) error
	Recv() (*HMACVerifyRequest, error)
	grpc.ServerStream
}

type vaultServiceHMACVerifyServer struct {
	grpc.ServerStream
}

func (x *vaultServiceHMACVerifyServer) SendAndClose(m *HMACVerifyResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *vaultServiceHMACVerifyServer) Recv() (*HMACVerifyRequest, error) {
	m := new(HMACVerifyRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _VaultService_Encrypt_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(VaultServiceServer).Encrypt(&vaultServiceEncryptServer{stream})
}

type VaultService_EncryptServer interface {
	Send(*EncryptResponse) error
	Recv() (*EncryptRequest, error)
	grpc.ServerStream
}

type vaultServiceEncryptServer struct {
	grpc.ServerStream
}

func (x *vaultServiceEncryptServer) Send(m *EncryptResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *vaultServiceEncryptServer) Recv() (*EncryptRequest, error) {
	m := new(EncryptRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _VaultService_Decrypt_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(VaultServiceServer).Decrypt(&vaultServiceDecryptServer{stream})
}

type VaultService_DecryptServer interface {
	Send(*DecryptResponse) error
	Recv() (*DecryptRequest, error)
	grpc.ServerStream
}

type vaultServiceDecryptServer struct {
	grpc.ServerStream
}

func (x *vaultServiceDecryptServer) Send(m *DecryptResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *vaultServiceDecryptServer) Recv() (*DecryptRequest, error) {
	m := new(DecryptRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// VaultService_ServiceDesc is the grpc.ServiceDesc for VaultService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VaultService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "system_vault.VaultService",
	HandlerType: (*VaultServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Seal",
			Handler:    _VaultService_Seal_Handler,
		},
		{
			MethodName: "Unseal",
			Handler:    _VaultService_Unseal_Handler,
		},
		{
			MethodName: "UpdateSealSecret",
			Handler:    _VaultService_UpdateSealSecret_Handler,
		},
		{
			MethodName: "GetStatus",
			Handler:    _VaultService_GetStatus_Handler,
		},
		{
			MethodName: "EnsureRSAKeyPair",
			Handler:    _VaultService_EnsureRSAKeyPair_Handler,
		},
		{
			MethodName: "GetRSAPublicKey",
			Handler:    _VaultService_GetRSAPublicKey_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RSASign",
			Handler:       _VaultService_RSASign_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "RSAVerify",
			Handler:       _VaultService_RSAVerify_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "HMACSign",
			Handler:       _VaultService_HMACSign_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "HMACVerify",
			Handler:       _VaultService_HMACVerify_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Encrypt",
			Handler:       _VaultService_Encrypt_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Decrypt",
			Handler:       _VaultService_Decrypt_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "vault.proto",
}
