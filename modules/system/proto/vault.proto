syntax = "proto3";

// import "google/protobuf/timestamp.proto";

package system_vault;

option go_package = "slamy/openBP/system/vault;vault";

message SealRequest {}
message SealResponse {}

message UnsealRequest {
    // Secret used for decripting the vault
    string secret = 1;
}
message UnsealResponse {
    // Indicates if vault was unsealed or not
    bool success = 1;
}

message UpdateSealSecretRequest {
    // Current administrator password. Administrator acess needed to modify secret. Administrator password will not be saved in the system.
    string currentAdminPassword = 1;
    // New administrator password. Administrator password will not be saved in the system.
    string newAdminPassword = 2;
    // New secret.
    string newSecret = 3;
}
message UpdateSealSecretResponse {}

message GetStatusRequest {}
message GetStatusResponse {
    // Is vault sealed or not
    bool sealed = 1;
}

message EnsureRSAKeyPairRequest {
    // Unique name of the key pair
    string keyName = 1;
}
message EnsureRSAKeyPairResponse {}

message GetRSAPublicKeyRequest {
    // Name of the key pair for which to get key
    string keyName = 1;
}
message GetRSAPublicKeyResponse {
    // Public key of the RSA key pair
    bytes publicKey = 1;
}

message RSASignRequest {
    // Name of the key pair to use
    string keyName = 1;
    // Data chunk to sign
    bytes data = 2;
}
message RSASignResponse {
    // Signature of the provided data
    bytes signature = 1;
}

message RSAVerifyRequest {
    // Name of the key pair to use for validation
    string keyName = 1;
    // Data chunk to validate
    bytes data = 2;
    // Signature to validate
    bytes signature = 3;
}
message RSAVerifyResponse {
    // Returns True if and only if provided data and its signature matches provided key-pair
    bool valid = 1;
}

message HMACSignRequest {
    // Block of data to sign
    bytes data = 1;
}
message HMACSignResponse {
    // Signature of the provided data
    bytes signature = 1;
}
message HMACVerifyRequest {
    // Block of data to sign
    bytes data = 1;
    // Signature to validate
    bytes signature = 2;
}
message HMACVerifyResponse {
    // Returns True if and only if provided data and its signature is valid
    bool valid = 1;
}

message EncryptRequest {
    // Block of data to encrypt
    bytes plainData = 1;
}
message EncryptResponse {
    // Encrypted block of the data
    bytes encryptedData = 1;
}
message DecryptRequest {
    // Encrypted block of the data
    bytes encryptedData = 1;
}
message DecryptResponse {
    // Decrypted block of the data
    bytes plainData = 1;
}

service VaultService {
    // Closes and encrypts vault. After sealing, most of the operations will not be accessible.
    rpc Seal(SealRequest) returns (SealResponse) {};
    // Decrypts and opens vault. Must be done before most of the operations with vault secrets.
    rpc Unseal(UnsealRequest) returns (UnsealResponse) {};
    // Set up new seal secret and reincrypt vault. The vault must be unsealed before this operation.
    rpc UpdateSealSecret(UpdateSealSecretRequest) returns (UpdateSealSecretResponse) {};
    // Returns current status of the vault.
    rpc GetStatus(GetStatusRequest) returns (GetStatusResponse) {};

    // Creates RSA key pair if it doesnt exist. Private key never leaves the HSM (hardware security module).
    rpc EnsureRSAKeyPair(EnsureRSAKeyPairRequest) returns (EnsureRSAKeyPairResponse) {};
    // Get public key of the RSA keypair.
    rpc GetRSAPublicKey(GetRSAPublicKeyRequest) returns (GetRSAPublicKeyResponse) {};
    // Sign message with RSA. It will use SHA512_RSA_PKCS (RS512) algorithm to sing the message.
    rpc RSASign(stream RSASignRequest) returns (RSASignResponse) {};
    // Validate signature of the message using RSA key-pairs public key. It will use SHA512_RSA_PKCS (RS512) algorithm to verify the message.
    rpc RSAVerify(stream RSAVerifyRequest) returns (RSAVerifyResponse) {};

    // Calculates HMAC signature for input data. HMAC secret never leaves the HSM (hardware security module). It automatically uses the best available HMAC algorithm for currently used HSM. 
    rpc HMACSign(stream HMACSignRequest) returns (HMACSignResponse) {};
    // Verifies HMAC signature of the data.
    rpc HMACVerify(stream HMACVerifyRequest) returns (HMACVerifyResponse) {};

    // Encrypts message. Encryption secret never leaves the HSM (hardware security module). It automatically uses the best available encryption algorithm for currently used HSM. It will only select the algorithm that is capable ofdecrypting from the middle of the whole data (partial decryption).
    rpc Encrypt(stream EncryptRequest) returns (stream EncryptResponse) {};
    // Decrypts message. If you want to decrypt part of the information from the middle of the whole data - ensure, that the first chunk of the data, that you are sending is padded by 2048 bit.
    rpc Decrypt(stream DecryptRequest) returns (stream DecryptResponse) {};
}