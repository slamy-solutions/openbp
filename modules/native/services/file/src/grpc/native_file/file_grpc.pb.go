// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.12.4
// source: file.proto

package native_files_grpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// FileServiceClient is the client API for FileService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FileServiceClient interface {
	// Creates new file. First message in the client stream must have file information. All next messages must have bytes chunk data. Information about created file file will be returned only on EOF of client stream.
	Create(ctx context.Context, opts ...grpc.CallOption) (FileService_CreateClient, error)
	// Check if file at specified location exists
	Exists(ctx context.Context, in *FileExistRequest, opts ...grpc.CallOption) (*FileExistResponse, error)
	// Get file information. Has same meaning as POSIX stat function
	Stat(ctx context.Context, in *StatFileRequest, opts ...grpc.CallOption) (*StatFileResponse, error)
	// Read data from the file
	Read(ctx context.Context, in *ReadFileRequest, opts ...grpc.CallOption) (FileService_ReadClient, error)
	// rpc Append();
	// rpc Write();
	Delete(ctx context.Context, in *DeleteFileRequest, opts ...grpc.CallOption) (*DeleteFileResponse, error)
	// Calculates SHA512 for the file data and adds it to the file information. If SHA512 was already calculated, returns stored hash value. This method is not concurrency safe. Writing to file while calculating hash will result in wrong hash stored in file information.
	CalculateSHA512(ctx context.Context, in *CalculateFileSHA512Request, opts ...grpc.CallOption) (*CalculateFileSHA512Response, error)
}

type fileServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFileServiceClient(cc grpc.ClientConnInterface) FileServiceClient {
	return &fileServiceClient{cc}
}

func (c *fileServiceClient) Create(ctx context.Context, opts ...grpc.CallOption) (FileService_CreateClient, error) {
	stream, err := c.cc.NewStream(ctx, &FileService_ServiceDesc.Streams[0], "/native_files.FileService/Create", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileServiceCreateClient{stream}
	return x, nil
}

type FileService_CreateClient interface {
	Send(*FileCreateRequest) error
	CloseAndRecv() (*FileCreateResponse, error)
	grpc.ClientStream
}

type fileServiceCreateClient struct {
	grpc.ClientStream
}

func (x *fileServiceCreateClient) Send(m *FileCreateRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *fileServiceCreateClient) CloseAndRecv() (*FileCreateResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(FileCreateResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileServiceClient) Exists(ctx context.Context, in *FileExistRequest, opts ...grpc.CallOption) (*FileExistResponse, error) {
	out := new(FileExistResponse)
	err := c.cc.Invoke(ctx, "/native_files.FileService/Exists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) Stat(ctx context.Context, in *StatFileRequest, opts ...grpc.CallOption) (*StatFileResponse, error) {
	out := new(StatFileResponse)
	err := c.cc.Invoke(ctx, "/native_files.FileService/Stat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) Read(ctx context.Context, in *ReadFileRequest, opts ...grpc.CallOption) (FileService_ReadClient, error) {
	stream, err := c.cc.NewStream(ctx, &FileService_ServiceDesc.Streams[1], "/native_files.FileService/Read", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileServiceReadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FileService_ReadClient interface {
	Recv() (*ReadFileResponse, error)
	grpc.ClientStream
}

type fileServiceReadClient struct {
	grpc.ClientStream
}

func (x *fileServiceReadClient) Recv() (*ReadFileResponse, error) {
	m := new(ReadFileResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileServiceClient) Delete(ctx context.Context, in *DeleteFileRequest, opts ...grpc.CallOption) (*DeleteFileResponse, error) {
	out := new(DeleteFileResponse)
	err := c.cc.Invoke(ctx, "/native_files.FileService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) CalculateSHA512(ctx context.Context, in *CalculateFileSHA512Request, opts ...grpc.CallOption) (*CalculateFileSHA512Response, error) {
	out := new(CalculateFileSHA512Response)
	err := c.cc.Invoke(ctx, "/native_files.FileService/CalculateSHA512", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FileServiceServer is the server API for FileService service.
// All implementations must embed UnimplementedFileServiceServer
// for forward compatibility
type FileServiceServer interface {
	// Creates new file. First message in the client stream must have file information. All next messages must have bytes chunk data. Information about created file file will be returned only on EOF of client stream.
	Create(FileService_CreateServer) error
	// Check if file at specified location exists
	Exists(context.Context, *FileExistRequest) (*FileExistResponse, error)
	// Get file information. Has same meaning as POSIX stat function
	Stat(context.Context, *StatFileRequest) (*StatFileResponse, error)
	// Read data from the file
	Read(*ReadFileRequest, FileService_ReadServer) error
	// rpc Append();
	// rpc Write();
	Delete(context.Context, *DeleteFileRequest) (*DeleteFileResponse, error)
	// Calculates SHA512 for the file data and adds it to the file information. If SHA512 was already calculated, returns stored hash value. This method is not concurrency safe. Writing to file while calculating hash will result in wrong hash stored in file information.
	CalculateSHA512(context.Context, *CalculateFileSHA512Request) (*CalculateFileSHA512Response, error)
	mustEmbedUnimplementedFileServiceServer()
}

// UnimplementedFileServiceServer must be embedded to have forward compatible implementations.
type UnimplementedFileServiceServer struct {
}

func (UnimplementedFileServiceServer) Create(FileService_CreateServer) error {
	return status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedFileServiceServer) Exists(context.Context, *FileExistRequest) (*FileExistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Exists not implemented")
}
func (UnimplementedFileServiceServer) Stat(context.Context, *StatFileRequest) (*StatFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stat not implemented")
}
func (UnimplementedFileServiceServer) Read(*ReadFileRequest, FileService_ReadServer) error {
	return status.Errorf(codes.Unimplemented, "method Read not implemented")
}
func (UnimplementedFileServiceServer) Delete(context.Context, *DeleteFileRequest) (*DeleteFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedFileServiceServer) CalculateSHA512(context.Context, *CalculateFileSHA512Request) (*CalculateFileSHA512Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CalculateSHA512 not implemented")
}
func (UnimplementedFileServiceServer) mustEmbedUnimplementedFileServiceServer() {}

// UnsafeFileServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FileServiceServer will
// result in compilation errors.
type UnsafeFileServiceServer interface {
	mustEmbedUnimplementedFileServiceServer()
}

func RegisterFileServiceServer(s grpc.ServiceRegistrar, srv FileServiceServer) {
	s.RegisterService(&FileService_ServiceDesc, srv)
}

func _FileService_Create_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FileServiceServer).Create(&fileServiceCreateServer{stream})
}

type FileService_CreateServer interface {
	SendAndClose(*FileCreateResponse) error
	Recv() (*FileCreateRequest, error)
	grpc.ServerStream
}

type fileServiceCreateServer struct {
	grpc.ServerStream
}

func (x *fileServiceCreateServer) SendAndClose(m *FileCreateResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *fileServiceCreateServer) Recv() (*FileCreateRequest, error) {
	m := new(FileCreateRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _FileService_Exists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileExistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).Exists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/native_files.FileService/Exists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).Exists(ctx, req.(*FileExistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_Stat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).Stat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/native_files.FileService/Stat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).Stat(ctx, req.(*StatFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_Read_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReadFileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FileServiceServer).Read(m, &fileServiceReadServer{stream})
}

type FileService_ReadServer interface {
	Send(*ReadFileResponse) error
	grpc.ServerStream
}

type fileServiceReadServer struct {
	grpc.ServerStream
}

func (x *fileServiceReadServer) Send(m *ReadFileResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _FileService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/native_files.FileService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).Delete(ctx, req.(*DeleteFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_CalculateSHA512_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CalculateFileSHA512Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).CalculateSHA512(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/native_files.FileService/CalculateSHA512",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).CalculateSHA512(ctx, req.(*CalculateFileSHA512Request))
	}
	return interceptor(ctx, in, info, handler)
}

// FileService_ServiceDesc is the grpc.ServiceDesc for FileService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FileService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "native_files.FileService",
	HandlerType: (*FileServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Exists",
			Handler:    _FileService_Exists_Handler,
		},
		{
			MethodName: "Stat",
			Handler:    _FileService_Stat_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _FileService_Delete_Handler,
		},
		{
			MethodName: "CalculateSHA512",
			Handler:    _FileService_CalculateSHA512_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Create",
			Handler:       _FileService_Create_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Read",
			Handler:       _FileService_Read_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "file.proto",
}
