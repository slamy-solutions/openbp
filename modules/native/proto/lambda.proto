syntax = "proto3";

package native_lambda;

option go_package = "slamy/openCRM/native/lambda;native_lambda_grpc";

message Lambda {
    // Namespace where lambda was created
    string namespace = 1;
    // Unique identifier inside UUID.
    string uuid = 2;
    // Type of the lambda runtime, that will run lambda
    string runtime = 3;
    // Unique identifier of the bundle. It is used for better lambda provisioning. If two lambdas have same bundle they will be executed using same execution pod
    bytes bundle = 4;
    // Make sure, that when this lambda will be executed, it will be executed only ones. If set to True, it will be very slow, because it has to use distributed lock to prevent multiple executions. Multiple executions are VERY rare, only at 0.1% of the times or less. Better implement you functions in such way, that several executions of the function with same data is ok.
    bool ensureExactlyOneDelivery = 5;
}

message CodeBundle {
    // Unique indentifier of the code bundle. Must be binded to the code. Better to use hash of the code or binary file.
    bytes uuid = 1;
    // Number of refenrences pointing to this code bundle. When number of references will be zero, bundle will be deleted.
    int32 references = 2;
}


// Structure in wich tasks are getting submited to the AMQP and received by runtime
message AMQPLambdaTaskRequest {
    Lambda lambda = 1;
    bytes data = 2;
}
// Response from the lambda runtime in the amqp
message AMQPLambdaTaskResponse {
    uint32 statusCode = 1;
    string message = 2;
    bytes data = 3;
}

message CreateLambdaRequest {
    // Namespace where to create lambda
    string namespace = 1;
    // Unique identifier.
    string uuid = 2;
    // Type of the lambda runtime, that will run lambda
    string runtime = 3;
    // Unique identifier of the bundle. Must be strictly binded to the code. SHA256 of the code/binary will be used if empty
    bytes bundle = 4;
    // Bundle binary data
    bytes data = 5;
    // Make sure, that when this lambda will be executed, it will be executed only ones. If set to True, it will be very slow, because it has to use distributed lock to prevent multiple executions. Multiple executions are VERY rare, only at 0.1% of the times or less. Better implement you functions in such way, that several executions of the function with same data is ok.
    bool ensureExactlyOneDelivery = 6;
}
message CreateLambdaResponse {
    // Created lambda
    Lambda lambda = 1;
}

message DeleteLambdaRequest {
    // Namespace of the lambda
    string namespace = 1;
    // Unique identifier of the lambda to delete.
    string uuid = 2;
}
message DeleteLambdaResponse {

}

message ExistsLambdaRequest {
    // Namespace of the lambda
    string namespace = 1;
    // Unique identifier of the lambda inside namespace.
    string uuid = 2;
}
message ExistsLambdaResponse {
    // Lambda exists or not
    bool exists = 1;
}

message GetLambdaRequest {
    // Namespace of the lambda
    string namespace = 1;
    // Unique identifier of the lambda to get.
    string uuid = 2;
}
message GetLambdaResponse {
    Lambda Lambda = 1;
}

message GetBundleRequest {
    // Unique identifier of the bundle to get.
    string bundle = 1;
}
message GetBundleResponse {
    // Bundle data
    bytes data = 1;
}

message ExecuteLambdaRequest {
    // Namespace of the lambda
    string namespace = 1;
    // UUID of the lambda
    string lambda = 2;
    // Data that will be passed to the function
    bytes data = 3;
    
    // Execution timeout in miliseconds
    uint64 timeout = 4;
}
message ExecuteLambdaResponse {
    // Execution result
    bytes result = 1;
}

message CallLambdaRequest {
    // Namespace of the lambda
    string namespace = 1;
    // UUID of the lambda
    string lambda = 2;
    // Data that will be passed to the function
    bytes data = 3;
}
message CallLambdaResponse {}

// Creates/Deletes/Updates/Agregates information about lambdas
service LambdaManagerService {
    // Create new lambda
    rpc Create(CreateLambdaRequest) returns (CreateLambdaResponse);
    // Deletes lambda
    rpc Delete(DeleteLambdaRequest) returns (DeleteLambdaResponse);
    // Checks if lambda exists or not
    rpc Exists(ExistsLambdaRequest) returns (ExistsLambdaResponse);
    // Get lambda information
    rpc Get(GetLambdaRequest) returns (GetLambdaResponse);
    // Gets lambda bundle
    rpc GetBundle(GetBundleRequest) returns (GetBundleResponse);
}

// Provides API to execute lambda functions
service LambdaEntrypointService {
    // Runs lambda and doesnt wait for response. Call will be resheduled on internal error, also it can be resheduled by lambda code.
    rpc Call(CallLambdaRequest) returns (CallLambdaResponse);
    // Runs function and returns its response. Returns error if something went wrong during the execution.
    rpc Execute(ExecuteLambdaRequest) returns (ExecuteLambdaResponse);
}