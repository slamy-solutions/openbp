syntax = "proto3";

package native_lambda;

option go_package = "slamy/openCRM/native/lambda;native_lambda_grpc";

message Lambda {
    // Unique identifier.
    string uuid = 1;
    // Type of the lambda environment, that will run lambda
    string environment = 2;
    // Unique identifier of the bundle. It is used for better lambda provisioning. If two lambdas have same bundle they will be executed using same execution pod
    bytes bundle = 3;
    // Make sure, that when this lambda will be executed, it will be executed only ones. If set to True, it will be very slow, because it has to use distributed lock to prevent multiple executions. Multiple executions are VERY rare, only at 0.1% of the times or less. Better implement you functions in such way, that several executions of the function with same data is ok.
    bool ensureExactlyOneDelivery = 4;
}

message CodeBundle {
    // Unique indentifier of the code bundle. Must be binded to the code. Better to use hash of the code or binary file.
    bytes uuid = 1;
    // Number of refenrences pointing to this code bundle. When number of references will be zero, bundle will be deleted.
    int32 references = 2;
}


message CreateLambdaRequest {
    // Unique identifier.
    string uuid = 10;
    // Type of the lambda environment, that will run lambda
    string environment = 11;
    // Unique identifier of the bundle. Must be strictly binded to the code. SHA256 of the code/binary will be used if empty
    bytes bundle = 12;
    // Bundle binary data
    bytes data = 21;
    // Make sure, that when this lambda will be executed, it will be executed only ones. If set to True, it will be very slow, because it has to use distributed lock to prevent multiple executions. Multiple executions are VERY rare, only at 0.1% of the times or less. Better implement you functions in such way, that several executions of the function with same data is ok.
    bool ensureExactlyOneDelivery = 13;
}
message CreateLambdaResponse {
    // Created lambda
    Lambda lambda = 1;
}

message DeleteLambdaRequest {
    // Unique identifier of the lambda to delete.
    string uuid = 1;
}
message DeleteLambdaResponse {

}

message ExistsLambdaRequest {
    // Unique identifier of the lambda.
    string uuid = 1;
}
message ExistsLambdaResponse {
    // Lambda exists or not
    bool exists = 1;
}

message GetLambdaRequest {
    // Unique identifier of the lambda to get.
    string uuid = 1;
}
message GetLambdaResponse {
    Lambda Lambda = 1;
}

message GetBundleRequest {
    // Unique identifier of the lambda to get.
    string bundle = 1;
}
message GetBundleResponse {
    // Chunk of bundle data
    bytes chunk = 1;
}

message ExecuteLambdaRequest {
    // UUID of the lambda
    string lambda = 1;
    // JSON data that will be passed to the function
    string data = 2;
    
    // Execution timeout in miliseconds
    //uint64 timeout = 2;
}
message ExecuteLambdaResponse {
    // JSON execution result
    string result = 1;
}

// Creates/Deletes/Updates/Agregates information about lambdas
service LambdaManagerService {
    // Create new lambda
    rpc Create(CreateLambdaRequest) returns (CreateLambdaResponse);
    // Deletes lambda
    rpc Delete(DeleteLambdaRequest) returns (DeleteLambdaResponse);
    // Checks if lambda exists or not
    rpc Exists(ExistsLambdaRequest) returns (ExistsLambdaResponse);
    // Get lambda information
    rpc Get(GetLambdaRequest) returns (GetLambdaResponse);
    // Gets lambda bundle
    rpc GetBundle(GetBundleRequest) returns (GetBundleResponse);
}

// Provides API to execute lambda functions
service LambdaEntrypointService {
    // Runs function and returns its response. Returns error if something went wrong during the execution.
    rpc Execute(ExecuteLambdaRequest) returns (ExecuteLambdaResponse);
}